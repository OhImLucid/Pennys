#!/usr/bin/env python3
"""
Penetration Testing Automation Tool
Main GUI application for automated penetration testing workflows

Author: Penetration Testing Automation Tool
Version: 1.0
Platform: Kali Linux
"""

import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox, filedialog
import threading
import os
import sys
from datetime import datetime

# Import our modules
import config
from scanner_engine import ScannerEngine
from report_generator import ReportGenerator


class PentestGUI:
    """Main GUI application for penetration testing automation"""

    def __init__(self, root):
        self.root = root
        self.root.title("Penetration Testing Automation Tool - Kali Linux")
        self.root.geometry("1200x800")

        # Initialize variables
        self.target_var = tk.StringVar()
        self.scan_running = False
        self.scanner_engine = None
        self.scan_thread = None

        # Test type checkboxes
        self.test_types = {
            'recon_quick': tk.BooleanVar(value=False),
            'recon_full': tk.BooleanVar(value=False),
            'recon_udp': tk.BooleanVar(value=False),
            'dns_enum': tk.BooleanVar(value=False),
            'whois': tk.BooleanVar(value=False),
            'web_whatweb': tk.BooleanVar(value=False),
            'web_nikto': tk.BooleanVar(value=False),
            'web_gobuster': tk.BooleanVar(value=False),
            'web_ssl': tk.BooleanVar(value=False),
            'proxmox_ports': tk.BooleanVar(value=False),
            'proxmox_web': tk.BooleanVar(value=False),
        }

        # Preset profiles
        self.preset_var = tk.StringVar(value="custom")

        # Setup UI
        self.setup_ui()

        # Create output directories
        config.create_output_directories()

        # Show legal warning
        self.show_legal_warning()

    def setup_ui(self):
        """Setup the user interface"""
        # Main container
        main_container = ttk.Frame(self.root, padding="10")
        main_container.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_container.columnconfigure(0, weight=1)
        main_container.rowconfigure(4, weight=1)

        # ===== HEADER =====
        header_frame = ttk.LabelFrame(main_container, text="Target Configuration", padding="10")
        header_frame.grid(row=0, column=0, sticky=(tk.W, tk.E), pady=5)
        header_frame.columnconfigure(1, weight=1)

        ttk.Label(header_frame, text="Target IP/Domain:").grid(row=0, column=0, sticky=tk.W, padx=5)
        target_entry = ttk.Entry(header_frame, textvariable=self.target_var, width=40)
        target_entry.grid(row=0, column=1, sticky=(tk.W, tk.E), padx=5)

        ttk.Label(header_frame, text="Examples: 192.168.1.100, example.com, proxmox.local",
                  foreground="gray").grid(row=1, column=1, sticky=tk.W, padx=5)

        # ===== SCAN PRESETS =====
        preset_frame = ttk.LabelFrame(main_container, text="Scan Presets", padding="10")
        preset_frame.grid(row=1, column=0, sticky=(tk.W, tk.E), pady=5)

        ttk.Radiobutton(preset_frame, text="Quick Scan (Fast, Common Tests)",
                        variable=self.preset_var, value="quick",
                        command=self.apply_preset).grid(row=0, column=0, sticky=tk.W, padx=5)

        ttk.Radiobutton(preset_frame, text="Full Scan (Comprehensive, Slower)",
                        variable=self.preset_var, value="full",
                        command=self.apply_preset).grid(row=0, column=1, sticky=tk.W, padx=5)

        ttk.Radiobutton(preset_frame, text="Web Application Focus",
                        variable=self.preset_var, value="web",
                        command=self.apply_preset).grid(row=0, column=2, sticky=tk.W, padx=5)

        ttk.Radiobutton(preset_frame, text="Proxmox Server Focus",
                        variable=self.preset_var, value="proxmox",
                        command=self.apply_preset).grid(row=0, column=3, sticky=tk.W, padx=5)

        ttk.Radiobutton(preset_frame, text="Custom Selection",
                        variable=self.preset_var, value="custom",
                        command=self.apply_preset).grid(row=0, column=4, sticky=tk.W, padx=5)

        # ===== TEST SELECTION =====
        tests_frame = ttk.LabelFrame(main_container, text="Select Tests to Run", padding="10")
        tests_frame.grid(row=2, column=0, sticky=(tk.W, tk.E), pady=5)

        # Reconnaissance tests
        recon_frame = ttk.LabelFrame(tests_frame, text="Reconnaissance", padding="5")
        recon_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N), padx=5, pady=5)

        ttk.Checkbutton(recon_frame, text="Quick Nmap Scan (Ports 1-1000)",
                        variable=self.test_types['recon_quick']).grid(row=0, column=0, sticky=tk.W)
        ttk.Checkbutton(recon_frame, text="Full Nmap Scan (All Ports + Scripts)",
                        variable=self.test_types['recon_full']).grid(row=1, column=0, sticky=tk.W)
        ttk.Checkbutton(recon_frame, text="UDP Scan (Top 100 Ports)",
                        variable=self.test_types['recon_udp']).grid(row=2, column=0, sticky=tk.W)
        ttk.Checkbutton(recon_frame, text="DNS Enumeration",
                        variable=self.test_types['dns_enum']).grid(row=3, column=0, sticky=tk.W)
        ttk.Checkbutton(recon_frame, text="WHOIS Lookup",
                        variable=self.test_types['whois']).grid(row=4, column=0, sticky=tk.W)

        # Web application tests
        web_frame = ttk.LabelFrame(tests_frame, text="Web Application Testing", padding="5")
        web_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N), padx=5, pady=5)

        ttk.Checkbutton(web_frame, text="WhatWeb (Technology Fingerprinting)",
                        variable=self.test_types['web_whatweb']).grid(row=0, column=0, sticky=tk.W)
        ttk.Checkbutton(web_frame, text="Nikto (Web Vulnerability Scanner)",
                        variable=self.test_types['web_nikto']).grid(row=1, column=0, sticky=tk.W)
        ttk.Checkbutton(web_frame, text="Gobuster (Directory Enumeration)",
                        variable=self.test_types['web_gobuster']).grid(row=2, column=0, sticky=tk.W)
        ttk.Checkbutton(web_frame, text="SSLScan (SSL/TLS Testing)",
                        variable=self.test_types['web_ssl']).grid(row=3, column=0, sticky=tk.W)

        # Proxmox tests
        proxmox_frame = ttk.LabelFrame(tests_frame, text="Proxmox Server Testing", padding="5")
        proxmox_frame.grid(row=0, column=2, sticky=(tk.W, tk.E, tk.N), padx=5, pady=5)

        ttk.Checkbutton(proxmox_frame, text="Proxmox Port Scan (22,111,8006,etc)",
                        variable=self.test_types['proxmox_ports']).grid(row=0, column=0, sticky=tk.W)
        ttk.Checkbutton(proxmox_frame, text="Proxmox Web Interface Scan",
                        variable=self.test_types['proxmox_web']).grid(row=1, column=0, sticky=tk.W)

        # ===== CONTROL BUTTONS =====
        control_frame = ttk.Frame(main_container, padding="10")
        control_frame.grid(row=3, column=0, sticky=(tk.W, tk.E), pady=5)

        self.start_button = ttk.Button(control_frame, text="‚ñ∂ Start Scan",
                                        command=self.start_scan, style="Accent.TButton")
        self.start_button.grid(row=0, column=0, padx=5)

        self.stop_button = ttk.Button(control_frame, text="‚¨õ Stop Scan",
                                       command=self.stop_scan, state=tk.DISABLED)
        self.stop_button.grid(row=0, column=1, padx=5)

        self.report_button = ttk.Button(control_frame, text="üìÑ Generate Report",
                                         command=self.generate_report, state=tk.DISABLED)
        self.report_button.grid(row=0, column=2, padx=5)

        ttk.Button(control_frame, text="üìÅ Open Output Folder",
                   command=self.open_output_folder).grid(row=0, column=3, padx=5)

        ttk.Button(control_frame, text="üîß Check Tools",
                   command=self.check_tools).grid(row=0, column=4, padx=5)

        ttk.Button(control_frame, text="‚Ñπ About",
                   command=self.show_about).grid(row=0, column=5, padx=5)

        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(control_frame, mode='indeterminate',
                                             variable=self.progress_var)
        self.progress_bar.grid(row=0, column=6, sticky=(tk.W, tk.E), padx=5)
        control_frame.columnconfigure(6, weight=1)

        # ===== OUTPUT LOG =====
        log_frame = ttk.LabelFrame(main_container, text="Scan Output Log", padding="5")
        log_frame.grid(row=4, column=0, sticky=(tk.W, tk.E, tk.N, tk.S), pady=5)
        log_frame.columnconfigure(0, weight=1)
        log_frame.rowconfigure(0, weight=1)

        self.log_text = scrolledtext.ScrolledText(log_frame, height=20, width=80,
                                                   wrap=tk.WORD, font=("Courier", 9))
        self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))

        # Configure text tags for colored output
        self.log_text.tag_config("error", foreground="red")
        self.log_text.tag_config("success", foreground="green")
        self.log_text.tag_config("warning", foreground="orange")
        self.log_text.tag_config("info", foreground="blue")

        # Status bar
        self.status_var = tk.StringVar(value="Ready")
        status_bar = ttk.Label(main_container, textvariable=self.status_var,
                               relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=5, column=0, sticky=(tk.W, tk.E))

    def log(self, message: str, is_error: bool = False):
        """Add message to log output"""
        self.log_text.insert(tk.END, message + "\n", "error" if is_error else "")
        self.log_text.see(tk.END)
        self.root.update_idletasks()

    def show_legal_warning(self):
        """Display legal warning on startup"""
        response = messagebox.askokcancel(
            "‚ö†Ô∏è Legal Warning - READ CAREFULLY",
            config.LEGAL_WARNING +
            "\n\nDo you confirm that you have proper authorization to test the target systems?",
            icon='warning'
        )

        if not response:
            self.log("‚ùå Legal warning not acknowledged. Please do not proceed without authorization.")
            self.start_button.config(state=tk.DISABLED)

    def apply_preset(self):
        """Apply preset configuration"""
        preset = self.preset_var.get()

        # Clear all
        for var in self.test_types.values():
            var.set(False)

        if preset == "quick":
            self.test_types['recon_quick'].set(True)
            self.test_types['dns_enum'].set(True)
            self.test_types['web_whatweb'].set(True)

        elif preset == "full":
            self.test_types['recon_full'].set(True)
            self.test_types['recon_udp'].set(True)
            self.test_types['dns_enum'].set(True)
            self.test_types['whois'].set(True)
            self.test_types['web_whatweb'].set(True)
            self.test_types['web_nikto'].set(True)
            self.test_types['web_gobuster'].set(True)
            self.test_types['web_ssl'].set(True)

        elif preset == "web":
            self.test_types['recon_quick'].set(True)
            self.test_types['web_whatweb'].set(True)
            self.test_types['web_nikto'].set(True)
            self.test_types['web_gobuster'].set(True)
            self.test_types['web_ssl'].set(True)

        elif preset == "proxmox":
            self.test_types['recon_quick'].set(True)
            self.test_types['proxmox_ports'].set(True)
            self.test_types['proxmox_web'].set(True)
            self.test_types['web_ssl'].set(True)

    def check_tools(self):
        """Check tool availability"""
        self.log("=== Checking Tool Availability ===")

        available_tools = config.check_tool_availability()
        missing_tools = []

        for tool_name, is_available in available_tools.items():
            if is_available:
                self.log(f"‚úì {tool_name}: Installed", False)
            else:
                self.log(f"‚úó {tool_name}: NOT FOUND", True)
                missing_tools.append(tool_name)

        if missing_tools:
            self.log(f"\n‚ö†Ô∏è  Missing tools: {', '.join(missing_tools)}", True)
            self.log("Install missing tools with: sudo apt install " + " ".join(missing_tools))
        else:
            self.log("\n‚úì All tools are installed!")

        self.log("\n=== Checking Wordlists ===")
        available_wordlists = config.check_wordlist_availability()

        for wl_name, is_available in available_wordlists.items():
            if is_available:
                self.log(f"‚úì {wl_name}: Found")
            else:
                self.log(f"‚úó {wl_name}: Not found", True)

    def start_scan(self):
        """Start the penetration testing scan"""
        # Validate target
        target = self.target_var.get().strip()
        if not target:
            messagebox.showerror("Error", "Please enter a target IP or domain")
            return

        # Check if any tests are selected
        if not any(var.get() for var in self.test_types.values()):
            messagebox.showerror("Error", "Please select at least one test to run")
            return

        # Confirm start
        tests_selected = [name for name, var in self.test_types.items() if var.get()]
        confirm_msg = f"Start penetration test on: {target}\n\n"
        confirm_msg += f"Tests selected: {len(tests_selected)}\n\n"
        confirm_msg += "This may take several minutes to hours depending on tests selected.\n\n"
        confirm_msg += "Confirm you have authorization to test this target?"

        if not messagebox.askyesno("Confirm Scan", confirm_msg):
            return

        # Disable controls
        self.scan_running = True
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.report_button.config(state=tk.DISABLED)
        self.progress_bar.start(10)

        # Clear log
        self.log_text.delete(1.0, tk.END)
        self.log(f"üéØ Starting penetration test on: {target}")
        self.log(f"‚è∞ Start time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        self.log("=" * 80)

        # Start scan in background thread
        self.scan_thread = threading.Thread(target=self.run_scan, args=(target,), daemon=True)
        self.scan_thread.start()

    def run_scan(self, target: str):
        """Run the actual scan (called in background thread)"""
        try:
            # Create scanner engine
            self.scanner_engine = ScannerEngine(output_callback=self.log)

            # Validate target
            is_valid, error_msg = self.scanner_engine.validate_target(target)
            if not is_valid:
                self.log(f"‚ùå Invalid target: {error_msg}", True)
                self.scan_complete(False)
                return

            # Run selected tests
            timestamp = self.scanner_engine.get_timestamp()

            # Reconnaissance tests
            if self.test_types['recon_quick'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['recon'],
                    self.scanner_engine.get_output_filename(target, "nmap_quick")
                )
                self.scanner_engine.nmap_quick_scan(target, output_file)

            if self.test_types['recon_full'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['recon'],
                    self.scanner_engine.get_output_filename(target, "nmap_full")
                )
                self.scanner_engine.nmap_full_scan(target, output_file)

            if self.test_types['recon_udp'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['recon'],
                    self.scanner_engine.get_output_filename(target, "nmap_udp")
                )
                self.scanner_engine.nmap_udp_scan(target, output_file)

            if self.test_types['dns_enum'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['recon'],
                    self.scanner_engine.get_output_filename(target, "dns_enum")
                )
                self.scanner_engine.dns_enumeration(target, output_file)

            if self.test_types['whois'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['recon'],
                    self.scanner_engine.get_output_filename(target, "whois")
                )
                self.scanner_engine.whois_lookup(target, output_file)

            # Web application tests
            if self.test_types['web_whatweb'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['web'],
                    self.scanner_engine.get_output_filename(target, "whatweb")
                )
                self.scanner_engine.whatweb_scan(target, output_file)

            if self.test_types['web_nikto'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['web'],
                    self.scanner_engine.get_output_filename(target, "nikto")
                )
                self.scanner_engine.nikto_scan(target, output_file)

            if self.test_types['web_gobuster'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['web'],
                    self.scanner_engine.get_output_filename(target, "gobuster")
                )
                self.scanner_engine.gobuster_scan(target, output_file)

            if self.test_types['web_ssl'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['web'],
                    self.scanner_engine.get_output_filename(target, "sslscan")
                )
                self.scanner_engine.sslscan(target, output_file)

            # Proxmox tests
            if self.test_types['proxmox_ports'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['proxmox'],
                    self.scanner_engine.get_output_filename(target, "proxmox_ports")
                )
                self.scanner_engine.proxmox_port_scan(target, output_file)

            if self.test_types['proxmox_web'].get():
                output_file = os.path.join(
                    config.OUTPUT_DIRS['proxmox'],
                    self.scanner_engine.get_output_filename(target, "proxmox_web")
                )
                self.scanner_engine.proxmox_web_scan(target, output_file)

            # Scan complete
            self.scan_complete(True)

        except Exception as e:
            self.log(f"\n‚ùå Error during scan: {str(e)}", True)
            self.scan_complete(False)

    def scan_complete(self, success: bool):
        """Handle scan completion"""
        self.root.after(0, self._scan_complete_ui, success)

    def _scan_complete_ui(self, success: bool):
        """Update UI after scan completes (must run in main thread)"""
        self.progress_bar.stop()
        self.scan_running = False
        self.start_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.DISABLED)

        if success:
            self.log("\n" + "=" * 80)
            self.log("‚úÖ Scan completed successfully!")
            self.log(f"‚è∞ End time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            self.log(f"üìÅ Output files saved to: {config.OUTPUT_BASE}")
            self.report_button.config(state=tk.NORMAL)
            self.status_var.set("Scan completed - Ready to generate report")
            messagebox.showinfo("Scan Complete",
                                "Penetration test completed successfully!\n\n"
                                "Click 'Generate Report' to create a summary.")
        else:
            self.log("\n" + "=" * 80)
            self.log("‚ö†Ô∏è  Scan completed with errors")
            self.status_var.set("Scan completed with errors")

    def stop_scan(self):
        """Stop the running scan"""
        if self.scanner_engine:
            self.log("\n‚ö†Ô∏è  Cancelling scan...")
            self.scanner_engine.cancel()
            self.status_var.set("Scan cancelled")

    def generate_report(self):
        """Generate markdown report from scan results"""
        if not self.scanner_engine:
            messagebox.showerror("Error", "No scan results available")
            return

        try:
            self.log("\n=== Generating Report ===")

            target = self.target_var.get().strip()
            scan_results = self.scanner_engine.get_scan_summary()

            # Create report generator
            report_gen = ReportGenerator(target, scan_results)

            # Generate report
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_target = target.replace('.', '_').replace(':', '_')
            report_file = os.path.join(
                config.OUTPUT_DIRS['reports'],
                f"report_{safe_target}_{timestamp}.md"
            )

            success = report_gen.generate_report(report_file)

            if success:
                self.log(f"‚úÖ Report generated: {report_file}")
                messagebox.showinfo("Report Generated",
                                    f"Report successfully generated:\n\n{report_file}\n\n"
                                    "Open it with any markdown viewer or text editor.")

                # Ask if user wants to open the report
                if messagebox.askyesno("Open Report", "Would you like to open the report now?"):
                    os.system(f"xdg-open '{report_file}' 2>/dev/null &")
            else:
                self.log("‚ùå Failed to generate report", True)
                messagebox.showerror("Error", "Failed to generate report")

        except Exception as e:
            self.log(f"‚ùå Error generating report: {str(e)}", True)
            messagebox.showerror("Error", f"Error generating report:\n{str(e)}")

    def open_output_folder(self):
        """Open the output folder in file manager"""
        os.system(f"xdg-open '{config.OUTPUT_BASE}' 2>/dev/null &")

    def show_about(self):
        """Show about dialog"""
        about_text = """
Penetration Testing Automation Tool
Version 1.0

A comprehensive GUI tool for automating penetration testing workflows
on Kali Linux.

Features:
- Network reconnaissance with Nmap
- Web application testing (Nikto, Gobuster, WhatWeb)
- Proxmox server testing
- Automated report generation
- Real-time output monitoring

‚ö†Ô∏è  Use only on systems you own or have explicit permission to test.

Developed for educational and authorized testing purposes only.
        """
        messagebox.showinfo("About", about_text)


def main():
    """Main entry point"""
    # Check if running on Linux
    if sys.platform != 'linux':
        print("‚ö†Ô∏è  WARNING: This tool is designed for Kali Linux.")
        print("Some features may not work correctly on other platforms.")

    # Create main window
    root = tk.Tk()

    # Set style
    style = ttk.Style()
    style.theme_use('clam')

    # Create application
    app = PentestGUI(root)

    # Run
    root.mainloop()


if __name__ == "__main__":
    main()
